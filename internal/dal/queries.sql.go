// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package dal

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (round_id, event_type, event_data, round_time, event_time) VALUES ($1, $2, $3, $4, $5) RETURNING id, round_id, round_time, event_time, event_type, event_data
`

type CreateEventParams struct {
	RoundID   int32
	EventType string
	EventData []byte
	RoundTime float64
	EventTime pgtype.Timestamp
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.RoundID,
		arg.EventType,
		arg.EventData,
		arg.RoundTime,
		arg.EventTime,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.RoundID,
		&i.RoundTime,
		&i.EventTime,
		&i.EventType,
		&i.EventData,
	)
	return i, err
}

type CreateEventsParams struct {
	RoundID   int32
	EventType string
	EventData []byte
	RoundTime float64
	EventTime pgtype.Timestamp
}

const createRound = `-- name: CreateRound :one
INSERT INTO rounds (map, start_time, end_time) VALUES ($1, $2, $3) RETURNING id, map, start_time, end_time
`

type CreateRoundParams struct {
	Map       string
	StartTime pgtype.Timestamp
	EndTime   pgtype.Timestamp
}

func (q *Queries) CreateRound(ctx context.Context, arg CreateRoundParams) (Round, error) {
	row := q.db.QueryRow(ctx, createRound, arg.Map, arg.StartTime, arg.EndTime)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.Map,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const getEvents = `-- name: GetEvents :many
SELECT id, round_id, round_time, event_time, event_type, event_data FROM events
`

func (q *Queries) GetEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.RoundID,
			&i.RoundTime,
			&i.EventTime,
			&i.EventType,
			&i.EventData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRound = `-- name: GetRound :one
SELECT id, map, start_time, end_time FROM rounds WHERE id = $1
`

func (q *Queries) GetRound(ctx context.Context, id int32) (Round, error) {
	row := q.db.QueryRow(ctx, getRound, id)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.Map,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const getRoundEvents = `-- name: GetRoundEvents :many
SELECT id, round_id, round_time, event_time, event_type, event_data FROM events WHERE round_id = $1
`

func (q *Queries) GetRoundEvents(ctx context.Context, roundID int32) ([]Event, error) {
	rows, err := q.db.Query(ctx, getRoundEvents, roundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.RoundID,
			&i.RoundTime,
			&i.EventTime,
			&i.EventType,
			&i.EventData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT nickname, steamid64 FROM users WHERE steamid64 = $1
`

func (q *Queries) GetUser(ctx context.Context, steamid64 int64) (User, error) {
	row := q.db.QueryRow(ctx, getUser, steamid64)
	var i User
	err := row.Scan(&i.Nickname, &i.Steamid64)
	return i, err
}

const putUser = `-- name: PutUser :one
INSERT INTO users (steamid64, nickname) VALUES ($1, $2) ON CONFLICT (steamid64) DO UPDATE SET nickname = $2 RETURNING nickname, steamid64
`

type PutUserParams struct {
	Steamid64 int64
	Nickname  string
}

func (q *Queries) PutUser(ctx context.Context, arg PutUserParams) (User, error) {
	row := q.db.QueryRow(ctx, putUser, arg.Steamid64, arg.Nickname)
	var i User
	err := row.Scan(&i.Nickname, &i.Steamid64)
	return i, err
}

const statsGetMostPlayedMaps = `-- name: StatsGetMostPlayedMaps :many
SELECT map, COUNT(map) as play_count FROM rounds WHERE start_time > $1 GROUP BY map ORDER BY play_count DESC
`

type StatsGetMostPlayedMapsRow struct {
	Map       string
	PlayCount int64
}

func (q *Queries) StatsGetMostPlayedMaps(ctx context.Context, startTime pgtype.Timestamp) ([]StatsGetMostPlayedMapsRow, error) {
	rows, err := q.db.Query(ctx, statsGetMostPlayedMaps, startTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatsGetMostPlayedMapsRow
	for rows.Next() {
		var i StatsGetMostPlayedMapsRow
		if err := rows.Scan(&i.Map, &i.PlayCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statsGetMostUsedWeaponsPerRound = `-- name: StatsGetMostUsedWeaponsPerRound :many
SELECT event_data->>'Weapon' AS weapon, COUNT(DISTINCT round_id) as usage_count FROM events WHERE event_time > $1 GROUP BY event_data->>'Weapon' ORDER BY usage_count DESC
`

type StatsGetMostUsedWeaponsPerRoundRow struct {
	Weapon     interface{}
	UsageCount int64
}

func (q *Queries) StatsGetMostUsedWeaponsPerRound(ctx context.Context, eventTime pgtype.Timestamp) ([]StatsGetMostUsedWeaponsPerRoundRow, error) {
	rows, err := q.db.Query(ctx, statsGetMostUsedWeaponsPerRound, eventTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatsGetMostUsedWeaponsPerRoundRow
	for rows.Next() {
		var i StatsGetMostUsedWeaponsPerRoundRow
		if err := rows.Scan(&i.Weapon, &i.UsageCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statsGetPlayerKilledByMost = `-- name: StatsGetPlayerKilledByMost :many
SELECT event_data->>'Attacker' as attacker, COUNT(event_data->>'Attacker') as total_kills FROM events WHERE event_type='kill' AND event_data->>'Victim'=$1::text GROUP BY event_data->>'Attacker' ORDER BY total_kills DESC LIMIT 5
`

type StatsGetPlayerKilledByMostRow struct {
	Attacker   interface{}
	TotalKills int64
}

func (q *Queries) StatsGetPlayerKilledByMost(ctx context.Context, victim string) ([]StatsGetPlayerKilledByMostRow, error) {
	rows, err := q.db.Query(ctx, statsGetPlayerKilledByMost, victim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatsGetPlayerKilledByMostRow
	for rows.Next() {
		var i StatsGetPlayerKilledByMostRow
		if err := rows.Scan(&i.Attacker, &i.TotalKills); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statsGetPlayersTopKills = `-- name: StatsGetPlayersTopKills :many
SELECT event_data->>'Attacker' as attacker, COUNT(event_data->>'Attacker') as total_kills FROM events WHERE event_type='kill' AND event_time > $1 GROUP BY event_data->>'Attacker' ORDER BY total_kills DESC LIMIT 5
`

type StatsGetPlayersTopKillsRow struct {
	Attacker   interface{}
	TotalKills int64
}

func (q *Queries) StatsGetPlayersTopKills(ctx context.Context, eventTime pgtype.Timestamp) ([]StatsGetPlayersTopKillsRow, error) {
	rows, err := q.db.Query(ctx, statsGetPlayersTopKills, eventTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatsGetPlayersTopKillsRow
	for rows.Next() {
		var i StatsGetPlayersTopKillsRow
		if err := rows.Scan(&i.Attacker, &i.TotalKills); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statsGetTotalWeaponDamage = `-- name: StatsGetTotalWeaponDamage :many
SELECT SUM((event_data->>'Damage')::int) as total_damage, event_data->>'Weapon' as weapon FROM events WHERE event_time > $1 AND event_type='damage' GROUP BY event_data->>'Weapon' ORDER BY total_damage DESC
`

type StatsGetTotalWeaponDamageRow struct {
	TotalDamage int64
	Weapon      interface{}
}

func (q *Queries) StatsGetTotalWeaponDamage(ctx context.Context, eventTime pgtype.Timestamp) ([]StatsGetTotalWeaponDamageRow, error) {
	rows, err := q.db.Query(ctx, statsGetTotalWeaponDamage, eventTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatsGetTotalWeaponDamageRow
	for rows.Next() {
		var i StatsGetTotalWeaponDamageRow
		if err := rows.Scan(&i.TotalDamage, &i.Weapon); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoundEndTime = `-- name: UpdateRoundEndTime :one
UPDATE rounds SET end_time = $1 WHERE id = $2 RETURNING id, map, start_time, end_time
`

type UpdateRoundEndTimeParams struct {
	EndTime pgtype.Timestamp
	ID      int32
}

func (q *Queries) UpdateRoundEndTime(ctx context.Context, arg UpdateRoundEndTimeParams) (Round, error) {
	row := q.db.QueryRow(ctx, updateRoundEndTime, arg.EndTime, arg.ID)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.Map,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}
